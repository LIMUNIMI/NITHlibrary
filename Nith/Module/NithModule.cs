using System;
using System.Collections.Generic;
using System.Linq;
using NITHlibrary.Nith.Internals;
using NITHlibrary.Nith.Preprocessors;
using NITHlibrary.Tools.Ports;

namespace NITHlibrary.Nith.Module
{
    /// <summary>
    /// The main NITH module class. Reads incoming raw data strings from a NITH sensor,
    /// and sends formatted SensorData to all the behaviors. Should be connected to a receiver as a listener.
    /// </summary>
    public class NithModule : IDisposable, IPortListener
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NithModule"/> class.
        /// </summary>
        public NithModule()
        {
            LastError = NithErrors.NaE;
        }

        /// <summary>
        /// Error behaviors are called when an error occurs.
        /// </summary>
        public List<INithErrorBehavior> ErrorBehaviors { get; protected set; } = new();

        /// <summary>
        /// Expected parameters for the sensor. If any parameter is specified, the behaviors will only be called
        /// if the sensor data contains the specified parameters. If empty, all data will be accepted.
        /// </summary>
        public List<NithParameters> ExpectedParameters { get; set; } = new();

        /// <summary>
        /// Expected sensor names. If any sensor name is specified, the behaviors will only be called if the sensor
        /// data contains the specified sensor name. If empty, all data will be accepted.
        /// </summary>
        public List<string> ExpectedSensorNames { get; set; } = new();

        /// <summary>
        /// Gets or sets the expected sensors versions. If any version is specified, the behaviors will only be called
        /// if the sensor data contains the specified version. If empty, all data will be accepted.
        /// </summary>
        public List<string> ExpectedVersions { get; set; } = new();

        /// <summary>
        /// Gets the last error generated by the module.
        /// </summary>
        public NithErrors LastError { get; protected set; }

        /// <summary>
        /// Gets the last sensor data received by the module.
        /// </summary>
        public NithSensorData LastSensorData { get; protected set; } = new();

        /// <summary>
        /// Sensor behaviors are called each time sensor data is received.
        /// </summary>
        public List<INithSensorBehavior> SensorBehaviors { get; protected set; } = new();

        /// <summary>
        /// Preprocessors are used to transform the data before sending it to the behaviors.
        /// </summary>
        public List<INithPreprocessor?> Preprocessors { get; protected set; } = new();

        /// <summary>
        /// Disposes the resources used by the <see cref="NithModule"/> class.
        /// </summary>
        public void Dispose()
        {
            ErrorBehaviors.Clear();
            SensorBehaviors.Clear();
        }

        /// <summary>
        /// Process the port data coming from the receiver.
        /// </summary>
        /// <param name="line">The raw data line received from the sensor.</param>
        void IPortListener.ReceivePortData(string line)
        {
            NithSensorData data = new();
            var error = NithErrors.NaE;

            try
            {
                // Save the raw line.
                data.RawLine = line;

                // The new protocol expects two segments:
                //  1. The main sensor data (must start with '$').
                //  2. The extra field which may be empty.
                //
                // Expected full format:
                // "$sensor_name-version|status_codes|arguments^extra"
                // where if no extra data is provided, extra is simply empty.

                // Split the line into two segments (maximum of 2 parts) using '^' as the delimiter.
                string[] segments = line.Split(new char[] { '^' }, 2);
                if (segments.Length != 2)
                {
                    throw new Exception("Incorrect number of segments. Expected a main segment and an extra field.");
                }

                // The first segment holds the main sensor data.
                var mainPart = segments[0];
                // The second segment is the extra field (which can be empty).
                data.ExtraData = segments[1];

                // Main part must start with '$'
                if (!mainPart.StartsWith("$"))
                {
                    throw new Exception("Main sensor data does not start with the '$' symbol.");
                }
                // Remove the starting '$'
                mainPart = mainPart.Substring(1);

                // Now split the main sensor data using the '|' delimiter.
                // Expected main format: sensor_name-version|status_codes|arguments
                var fields = mainPart.Split('|');
                if (fields.Length != 3)
                {
                    throw new Exception("Main sensor data does not have exactly three fields separated by '|'.");
                }

                // Field 0: sensor_name-version (split by '-')
                var sensorTokens = fields[0].Split('-');
                if (sensorTokens.Length != 2)
                {
                    throw new Exception("Sensor name and version format is invalid.");
                }
                data.SensorName = sensorTokens[0];
                data.Version = sensorTokens[1];

                // Field 1: status code; parse it with your parser.
                data.StatusCode = NithParsers.ParseStatusCode(fields[1]);

                // Field 2: arguments separated by '&'
                var arguments = fields[2].Split('&', StringSplitOptions.RemoveEmptyEntries);
                foreach (var arg in arguments)
                {
                    // Each argument must be in the form: valuetype=value
                    string[] s = arg.Split('=', 2);
                    if (s.Length != 2)
                    {
                        throw new Exception("Argument does not have a valid key=value format.");
                    }
                    var argumentName = s[0];
                    var argumentValue = s[1];

                    NithParameterValue paramValue;
                    // Check if the value is in the composite range format, i.e. enclosed in [...]
                    if (argumentValue.StartsWith("[") && argumentValue.EndsWith("]"))
                    {
                        // Remove the enclosing brackets.
                        var inner = argumentValue.Substring(1, argumentValue.Length - 2);
                        // Split by '/' expecting exactly three tokens: min, value and max.
                        var tokens = inner.Split('/', StringSplitOptions.RemoveEmptyEntries);
                        if (tokens.Length != 3)
                        {
                            throw new Exception($"Range format for parameter '{argumentName}' is invalid. Expected format: [min/value/max].");
                        }
                        // Create the composite value using the three tokens.
                        paramValue = new NithParameterValue(NithParsers.ParseField(argumentName), tokens[0], tokens[1], tokens[2]);
                    }
                    else
                    {
                        // Simple value case.
                        paramValue = new NithParameterValue(NithParsers.ParseField(argumentName), argumentValue);
                    }
                    data.Values.Add(paramValue);
                }

                // Further validations on sensor name, version, status and expected parameters.
                if (!(ExpectedSensorNames.Contains(data.SensorName) || ExpectedSensorNames.Count == 0))
                {
                    error = NithErrors.Name;
                }
                else if (!(ExpectedVersions.Contains(data.Version) || ExpectedVersions.Count == 0))
                {
                    error = NithErrors.Version;
                }
                else if (data.StatusCode == NithStatusCodes.ERR)
                {
                    error = NithErrors.StatusCode;
                }
                else if (ExpectedParameters.Count != 0 && !data.ContainsParameters(ExpectedParameters))
                {
                    error = NithErrors.Parameters;
                }
                else
                {
                    error = NithErrors.Ok;
                }
            }
            catch (Exception)
            {
                error = NithErrors.OutputCompliance;
            }

            // Transform data using preprocessors.
            foreach (var preProc in Preprocessors)
            {
                data = preProc.TransformData(data);
            }

            // Call error behaviors if necessary.
            foreach (var ebeh in ErrorBehaviors)
            {
                ebeh.HandleError(error);
            }

            // Finally, call sensor behaviors.
            foreach (var sbeh in SensorBehaviors)
            {
                sbeh.HandleData(data);
            }

            LastSensorData = data;
            LastError = error;
        }
    }
}