using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using NITHlibrary.Nith.Internals;
using NITHlibrary.Nith.Preprocessors;
using NITHlibrary.Tools.Ports;

namespace NITHlibrary.Nith.Module
{
    /// <summary>
    /// The main NITH module class. Reads incoming raw data strings from a NITH sensor,
    /// and sends formatted SensorData to all the behaviors. Should be connected to a receiver as a listener.
    /// </summary>
    public class NithModule : IDisposable, IPortListener
    {
        private readonly Channel<string> _dataChannel;
        private readonly CancellationTokenSource _cancellationTokenSource;
        private readonly Task _processingTask;
        private readonly object _lastSensorDataLock = new();
        private NithSensorData _lastSensorData = new();
        private int _droppedSamplesCount = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="NithModule"/> class.
        /// </summary>
        public NithModule()
        {
            LastError = NithErrors.NaE;
            
            // Initialize the channel for async processing
            var channelOptions = new BoundedChannelOptions(MaxQueueSize)
            {
                FullMode = BoundedChannelFullMode.Wait // Will be updated based on OverflowBehavior
            };
            _dataChannel = Channel.CreateBounded<string>(channelOptions);
            
            // Start the background processing task
            _cancellationTokenSource = new CancellationTokenSource();
            _processingTask = Task.Run(() => ProcessDataAsync(_cancellationTokenSource.Token));
        }

        /// <summary>
        /// Error behaviors are called when an error occurs.
        /// </summary>
        public List<INithErrorBehavior> ErrorBehaviors { get; protected set; } = new();

        /// <summary>
        /// Expected parameters for the sensor. If any parameter is specified, the behaviors will only be called
        /// if the sensor data contains the specified parameters. If empty, all data will be accepted.
        /// </summary>
        public List<NithParameters> ExpectedParameters { get; set; } = new();

        /// <summary>
        /// Expected sensor names. If any sensor name is specified, the behaviors will only be called if the sensor
        /// data contains the specified sensor name. If empty, all data will be accepted.
        /// </summary>
        public List<string> ExpectedSensorNames { get; set; } = new();

        /// <summary>
        /// Gets or sets the expected sensors versions. If any version is specified, the behaviors will only be called
        /// if the sensor data contains the specified version. If empty, all data will be accepted.
        /// </summary>
        public List<string> ExpectedVersions { get; set; } = new();

        /// <summary>
        /// Gets the last error generated by the module.
        /// </summary>
        public NithErrors LastError { get; protected set; }

        /// <summary>
        /// Gets the last sensor data received by the module.
        /// Thread-safe property accessed via lock.
        /// </summary>
        public NithSensorData LastSensorData
        {
            get
            {
                lock (_lastSensorDataLock)
                {
                    return _lastSensorData;
                }
            }
            protected set
            {
                lock (_lastSensorDataLock)
                {
                    _lastSensorData = value;
                }
            }
        }

        /// <summary>
        /// Sensor behaviors are called each time sensor data is received.
        /// </summary>
        public List<INithSensorBehavior> SensorBehaviors { get; protected set; } = new();

        /// <summary>
        /// Preprocessors are used to transform the data before sending it to the behaviors.
        /// </summary>
        public List<INithPreprocessor?> Preprocessors { get; protected set; } = new();

        /// <summary>
        /// Gets or sets the maximum queue size for incoming data.
        /// Default is 50 samples. Larger values increase latency but reduce dropped samples.
        /// </summary>
        public int MaxQueueSize { get; set; } = 50;

        /// <summary>
        /// Gets or sets the behavior when the queue is full.
        /// Default is DropOldest for real-time responsiveness.
        /// </summary>
        public QueueOverflowBehavior OverflowBehavior { get; set; } = QueueOverflowBehavior.DropOldest;

        /// <summary>
        /// Gets or sets whether to use asynchronous queue-based processing.
        /// Default is true (opt-out). Set to false to use legacy synchronous processing.
        /// </summary>
        public bool UseAsyncProcessing { get; set; } = true;

        /// <summary>
        /// Gets the current number of samples waiting in the processing queue.
        /// Useful for monitoring performance.
        /// </summary>
        public int QueueDepth => _dataChannel.Reader.Count;

        /// <summary>
        /// Gets the total number of samples dropped due to queue overflow.
        /// </summary>
        public int DroppedSamplesCount => _droppedSamplesCount;

        /// <summary>
        /// Resets the dropped samples counter.
        /// </summary>
        public void ResetDroppedSamplesCount()
        {
            Interlocked.Exchange(ref _droppedSamplesCount, 0);
        }

        /// <summary>
        /// Disposes the resources used by the <see cref="NithModule"/> class.
        /// </summary>
        public void Dispose()
        {
            // Signal cancellation and wait for processing task to complete
            _cancellationTokenSource.Cancel();
            try
            {
                _processingTask.Wait(1000); // Wait up to 1 second
            }
            catch (AggregateException)
            {
                // Expected when task is cancelled
            }

            _cancellationTokenSource.Dispose();
            ErrorBehaviors.Clear();
            SensorBehaviors.Clear();
        }

        /// <summary>
        /// Process the port data coming from the receiver.
        /// </summary>
        /// <param name="line">The raw data line received from the sensor.</param>
        void IPortListener.ReceivePortData(string line)
        {
            if (!UseAsyncProcessing)
            {
                // Legacy synchronous processing
                ProcessDataSync(line);
                return;
            }

            // Async queue-based processing
            bool queued = false;

            switch (OverflowBehavior)
            {
                case QueueOverflowBehavior.DropOldest:
                    // Try to write, if full, remove oldest and try again
                    while (!_dataChannel.Writer.TryWrite(line))
                    {
                        if (_dataChannel.Reader.TryRead(out _))
                        {
                            Interlocked.Increment(ref _droppedSamplesCount);
                        }
                    }
                    queued = true;
                    break;

                case QueueOverflowBehavior.DropNewest:
                    // Try to write, if full, drop this new sample
                    queued = _dataChannel.Writer.TryWrite(line);
                    if (!queued)
                    {
                        Interlocked.Increment(ref _droppedSamplesCount);
                    }
                    break;

                case QueueOverflowBehavior.Block:
                    // Block until space is available (may cause lag)
                    _dataChannel.Writer.TryWrite(line);
                    queued = true;
                    break;
            }
        }

        /// <summary>
        /// Background task that processes queued data asynchronously.
        /// </summary>
        private async Task ProcessDataAsync(CancellationToken cancellationToken)
        {
            await foreach (var line in _dataChannel.Reader.ReadAllAsync(cancellationToken))
            {
                ProcessDataSync(line);
            }
        }

        /// <summary>
        /// Synchronous data processing (used by both legacy mode and async worker).
        /// </summary>
        private void ProcessDataSync(string line)
        {
            NithSensorData data = new();
            var error = NithErrors.NaE;

            try
            {
                // Save the raw line.
                data.RawLine = line;

                // The new protocol expects two segments:
                //  1. The main sensor data (must start with '$').
                //  2. The extra field which may be empty.
                //
                // Expected full format:
                // "$sensor_name-version|status_codes|arguments^extra"
                // where if no extra data is provided, extra is simply empty.

                // Split the line into two segments (maximum of 2 parts) using '^' as the delimiter.
                string[] segments = line.Split(new char[] { '^' }, 2);
                if (segments.Length != 2)
                {
                    throw new Exception("Incorrect number of segments. Expected a main segment and an extra field.");
                }

                // The first segment holds the main sensor data.
                var mainPart = segments[0];
                // The second segment is the extra field (which can be empty).
                data.ExtraData = segments[1];

                // Main part must start with '$'
                if (!mainPart.StartsWith("$"))
                {
                    throw new Exception("Main sensor data does not start with the '$' symbol.");
                }
                // Remove the starting '$'
                mainPart = mainPart.Substring(1);

                // Now split the main sensor data using the '|' delimiter.
                // Expected main format: sensor_name-version|status_codes|arguments
                var fields = mainPart.Split('|');
                if (fields.Length != 3)
                {
                    throw new Exception("Main sensor data does not have exactly three fields separated by '|'.");
                }

                // Field 0: sensor_name-version (split by '-')
                var sensorTokens = fields[0].Split('-');
                if (sensorTokens.Length != 2)
                {
                    throw new Exception("Sensor name and version format is invalid.");
                }
                data.SensorName = sensorTokens[0];
                data.Version = sensorTokens[1];

                // Field 1: status code; parse it with your parser.
                data.StatusCode = NithParsers.ParseStatusCode(fields[1]);

                // Field 2: arguments separated by '&'
                var arguments = fields[2].Split('&', StringSplitOptions.RemoveEmptyEntries);
                foreach (var arg in arguments)
                {
                    // Each argument must be in the form: valuetype=value
                    string[] s = arg.Split('=', 2);
                    if (s.Length != 2)
                    {
                        throw new Exception("Argument does not have a valid key=value format.");
                    }
                    var argumentName = s[0];
                    var argumentValue = s[1];

                    NithParameterValue paramValue;
                    // Check if the value is in the composite range format, i.e. enclosed in [...]
                    if (argumentValue.StartsWith("[") && argumentValue.EndsWith("]"))
                    {
                        // Remove the enclosing brackets.
                        var inner = argumentValue.Substring(1, argumentValue.Length - 2);
                        // Split by '/' expecting exactly three tokens: min, value and max.
                        var tokens = inner.Split('/', StringSplitOptions.RemoveEmptyEntries);
                        if (tokens.Length != 3)
                        {
                            throw new Exception($"Range format for parameter '{argumentName}' is invalid. Expected format: [min/value/max].");
                        }
                        // Create the composite value using the three tokens.
                        paramValue = new NithParameterValue(NithParsers.ParseField(argumentName), tokens[0], tokens[1], tokens[2]);
                    }
                    else
                    {
                        // Simple value case.
                        paramValue = new NithParameterValue(NithParsers.ParseField(argumentName), argumentValue);
                    }
                    data.Values.Add(paramValue);
                }

                // Further validations on sensor name, version, status and expected parameters.
                if (!(ExpectedSensorNames.Contains(data.SensorName) || ExpectedSensorNames.Count == 0))
                {
                    error = NithErrors.Name;
                }
                else if (!(ExpectedVersions.Contains(data.Version) || ExpectedVersions.Count == 0))
                {
                    error = NithErrors.Version;
                }
                else if (data.StatusCode == NithStatusCodes.ERR)
                {
                    error = NithErrors.StatusCode;
                }
                else if (ExpectedParameters.Count != 0 && !data.ContainsParameters(ExpectedParameters))
                {
                    error = NithErrors.Parameters;
                }
                else
                {
                    error = NithErrors.Ok;
                }
            }
            catch (Exception)
            {
                error = NithErrors.OutputCompliance;
            }

            // Transform data using preprocessors.
            foreach (var preProc in Preprocessors)
            {
                data = preProc.TransformData(data);
            }

            // Call error behaviors if necessary.
            foreach (var ebeh in ErrorBehaviors)
            {
                ebeh.HandleError(error);
            }

            // Finally, call sensor behaviors.
            foreach (var sbeh in SensorBehaviors)
            {
                sbeh.HandleData(data);
            }

            LastSensorData = data;
            LastError = error;
        }
    }
}